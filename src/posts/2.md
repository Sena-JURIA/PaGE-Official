---
title: "繰り返し2乗法で高速にべき乗を求めよう"
date: "2025年7月17日"
authorId: "yes_antikiss"
excerpt: "べき乗を高速化"
imageUrl: "https://placehold.co/400x250/FF851B/FFFFFF?text=a^b"
tags: ["C++", "メモ"]
---

みなさんこんにちは、yesです。
今回は整数のべき乗(a^b)を高速に求める方法をまとめようと思います。

## 普通に書くと

まず初めに思いつくのはこういうコードでしょう。

```cpp
long long power(long long a, long long b){
    long long res = 1;
    for (long long i = 0; i < b; i++) {
        res *= a;
    }
    return res;
};
```

しかしこのコードだと、bが非常に大きい場合(b = 10^9など)の場合非常に時間がかかってしまいます。

## 考え方
ここで、次の性質を使います。

> x^(a+b) = x^a * x^b

この性質を使うと、例えば2^23の場合、

> 2^23 = 2^16 * 2^4 * 2^2 * 2^1 = 2^(2^4) * 2^(2^2) * 2^(2^1) * 2^(2^0)

のように、bを2進数で表現して分割することができます。

さらに言い換えると、23=10111(2)というように、1桁目からbitが立っているか(2進数のn桁目が1か？)と表現できるので、次のように書けます。

```cpp
long long integer_pow(long long a, long long b) {
    long long res = 1;
    long long t = a;
    for (int i = 0; i < 63; i++) { // b <= LLONG_MAX = 2^63 - 1
        if (b & (1LL << i)) res *= t;
        t *= t;
    }
    return res;
};
```

ここで、**b & (1LL << i)** が何をしているのかを説明します。

### 1LL << i とは？

これは　**1という数をi回左シフト(左にずらす)** ことです。
例を挙げると、

- i = 0 のとき、**1 << 0 = 1** 2進数だと00001
- i = 1 のとき、**1 << 1 = 2** 2進数だと00010
- i = 2 のとき、**1 << 2 = 4** 2進数だと00100
- i = 3 のとき、**1 << 3 = 8** 2進数だと01000
- i = 4 のとき、**1 << 4 = 16** 2進数だと10000

見ての通り、1 << xは **1 * 2^x** と対応していることが分かります。
(ちなみに、1LLのLLはlong long型にするための接尾辞です)

### & とは？

**&** は、2つの数を2進数で表したときに、両方の同じ桁が **1** の場合だけ、その桁が **1** になるという計算（論理積）をすることです。

### 結局 b & (1LL << i) は何をしているか

まず b = 23 とします。
そうすると、

- i = 0 の時は (10111 & 00001) = **00001** = 1
- i = 1 の時は (10111 & 00010) = **00010** = 2
- i = 2 の時は (10111 & 00100) = **00100** = 4
- i = 3 の時は (10111 & 01000) = **00000** = 0
- i = 4 の時は (10111 & 10000) = **10000** = 16

となります。

C++では整数型の場合0がfalse、それ以外ならtrueと扱うので、桁ごとにbitが立っているかを判定することができます。

## 使用例

```cpp
#include <iostream>

long long integer_pow(long long a, long long b) {
    /* 省略 */
};

int main() {
    std::cout << "10^3 : " << integer_pow(10, 3) << '\n';
    std::cout << "3^10 : " << integer_pow(3, 10) << '\n';
    std::cout << "2^50 : " << integer_pow(2, 50) << '\n';
}
```

### Output

```
10^3 : 1000
3^10 : 59049
2^50 : 1125899906842624
```

## 改善点

この方法で正確に求められますが、数が非常に大きくなりオーバーフローしてしまう可能性があるので、適宜modを取るようにしても良いかなと思います。
また、aをdouble型にしたときbを負にしても数を表現出来るので、それに対応するように書いてもいいと思います。

## mod をとる場合

競技プログラミングではmod 998244353での答えを求めることが多々あるので、次のように書くと便利です。

```cpp
long long mod_pow(long long a, long long b, long long mod = 998244353) {
    long long res = 1;
    long long t = a % mod;
    for (int i = 0; i < 63; i++) { // b <= LLONG_MAX = 2^63 - 1
        if (b & (1LL << i)) res = res * t % mod;
        t = t * t % mod;
    }
    return res;
};
```

AtCoder Libraryのmodintを使わない人でべき乗をしたい！という方は参考にしてみてください